/* Copyright 2022, The Android Open Source Project, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *   http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

syntax = "proto3";

package com.google.android.attestation;

import "google/protobuf/duration.proto";
import "google/protobuf/timestamp.proto";
import "google/protobuf/wrappers.proto";
import "google/type/date.proto";

option java_package = "com.google.android.attestation";

message KeyDescription {
  // The key attestation format version
  .google.protobuf.UInt32Value attestation_version = 1;

  // This data structure indicates the extent to which a software feature, such
  // as a key pair, is protected based on its location within the device.
  // Note: The numeric values do not match the ASN.1 representation.
  enum SecurityLevel {
    SECURITY_LEVEL_UNSPECIFIED = 0;
    // The logic for creating and managing the feature is implemented in the
    // Android system. For the purposes of creating and storing key pairs, this
    // location is less secure than the TEE but is more secure than your app's
    // process space.
    SOFTWARE = 1;
    // The logic for creating and managing the feature is implemented in secure
    // hardware, such as a TEE. For the purposes of creating and storing key
    // pairs, this location is more secure because secure hardware is highly
    // resistant to remote compromise.
    TRUSTED_ENVIRONMENT = 2;
    // The logic for creating and managing the feature is implemented in a
    // dedicated hardware security module. For the purposes of creating and
    // storing key pairs, this location is more secure because it is highly
    // resistant to remote compromise and hardware attacks against the module.
    // Present only in key attestation version ATTESTATION_V_THREE and later.
    STRONG_BOX = 3;
  }

  // The security level of the attestation.
  SecurityLevel attestation_security_level = 2;

  // The version of the KeyMint (or Keymaster) implementation
  .google.protobuf.UInt32Value key_mint_version = 3;

  // The security level of the KeyMint implementation.
  SecurityLevel key_mint_security_level = 4;

  bytes attestation_challenge = 5;

  // This value identifies the deviceâ€”but only for a limited period of time. It
  // is computed and is only used by system apps. In all other apps, uniqueId is
  // empty.
  bytes unique_id = 6;

  // This data structure contains the key pair's properties themselves, as
  // defined in the KeyMint hardware abstraction layer (HAL). You compare
  // these values to the device's current state or to a set of expected values
  // to verify that a key pair is still valid for use in your app.
  message AuthorizationList {
    // Purposes for which the key may be used.
    enum KeyPurpose {
      ENCRYPT = 0;
      DECRYPT = 1;
      SIGN = 2;
      VERIFY = 3;
      /* 4 is reserved */
      WRAP_KEY = 5;
      AGREE_KEY = 6;
      ATTEST_KEY = 7;
    }

    repeated KeyPurpose purposes = 1;

    // Specifies the cryptographic algorithm with which the key is used.
    enum Algorithm {
      ALGORITHM_UNSPECIFIED = 0;
      RSA = 1;
      EC = 3;
      AES = 32;
      TRIPLE_DES = 33;
      HMAC = 128;
    }

    Algorithm algorithm = 2;

    // Specifies the size, in bits, of the key, measuring in the normal way for
    // the key's algorithm. For example, for RSA keys, key_size specifies
    // the size of the public modulus. For AES keys it specifies the length of
    // the secret key material.
    .google.protobuf.UInt32Value key_size = 3;

    // Digest algorithms that may be used with the key to perform signing and
    // verification operations. This field is relevant to RSA, ECDSA and HMAC.
    enum Digest {
      DIGEST_NONE = 0;
      MD5 = 1;
      SHA1 = 2;
      SHA_2_224 = 3;
      SHA_2_256 = 4;
      SHA_2_384 = 5;
      SHA_2_512 = 6;
    }

    repeated Digest digests = 4;

    enum PaddingMode {
      // Unused; exists only because proto enums must start with 0.
      PADDING_UNSPECIFIED = 0;
      // NONE may be used with either RSA or AES keys.
      PADDING_NONE = 1;
      // RSA_OAEP is used only for RSA encryption/decryption keys and specifies
      // RSA PKCS#1v2 OAEP padding.
      RSA_OAEP = 2;
      // RSA_PSS is used only for RSA signing/verification keys and specifies
      // RSA PKCS#1v2 PSS padding.
      RSA_PSS = 3;
      // RSA_PKCS1_1_5_ENCRYPT is used only for RSA encryption/decryption keys
      // and specifies RSA PKCS#1 v1.5 randomized padding.
      RSA_PKCS1_1_5_ENCRYPT = 4;
      // RSA_PKCS1_1_5_SIGN is used only for RSA signing/verification keys and
      // specifies RSA PKCS#1 v1.5 deterministic padding.
      RSA_PKCS1_1_5_SIGN = 5;
      // PKCS7 may only be used with AES keys, and only with ECB and CBC modes.
      PKCS7 = 64;
    }

    // Specifies the padding modes that may be used with the key. This field is
    // relevant to RSA and AES keys.
    repeated PaddingMode paddings = 5;

    // In Keymaster 1, the curve used for EC keys was guessed from the specified
    // key size. To improve flexibility moving forward, Keymaster 2 introduced
    // an explicit way to specify curves. EC key generation requests may have
    // ec_curve, key_size, or both.
    // Note: The numeric values do not match the ASN.1 representation.
    enum EcCurve {
      // Needed to distinguish unset ec_curve fields.
      EC_CURVE_UNSPECIFIED = 0;
      P_224 = 1;
      P_256 = 2;
      P_384 = 3;
      P_521 = 4;
      CURVE_25519 = 5;
    }

    // The set of parameters used to generate an elliptic curve (EC) key pair,
    // which uses ECDSA for signing and verification, within the Android system
    // keystore.
    EcCurve ec_curve = 6;

    // Specifies the value of the public exponent for an RSA key pair. This
    // field is relevant only to RSA keys, and necessary for all RSA keys. The
    // value is a 64-bit unsigned integer that satisfies the requirements of an
    // RSA public exponent. This value has to be a prime number. Trustlets
    // support the value 2^16+1 and may support other reasonable values, in
    // particular the value 3.  If no exponent is specified or if the specified
    // exponent is not supported, key generation fails.
    .google.protobuf.UInt64Value rsa_public_exponent = 7;

    // Corresponds to rollback_resistant.
    // Present only in ATTESTATION_V_THREE and later
    bool rollback_resistance = 8;

    // Specifies the date and time at which the key becomes active. Prior to
    // this time, any attempt to use the key fails.
    .google.protobuf.Timestamp active_datetime = 9;

    // Specifies the date and time at which the key expires for signing and
    // encryption purposes. After this time, any attempt to use a key with
    // KeyPurpose.SIGN or KeyPurpose.ENCRYPT provided to begin fails.
    .google.protobuf.Timestamp origination_expire_datetime = 10;

    // Specifies the date and time at which the key expires for verification and
    // decryption purposes. After this time, any attempt to use a key with
    // KeyPurpose.VERIFY or KeyPurpose.DECRYPT provided to begin fails.
    .google.protobuf.Timestamp usage_expire_datetime = 11;

    // Specifies that no authentication is required to use this key.
    bool no_auth_required = 12;

    enum UserAuthType {
      USER_AUTH_TYPE_UNSPECIFIED = 0;
      PASSWORD = 1; // 1 << 0
      BIOMETRIC = 2; // 1 << 1
    }

    // Specifies the types of user authenticators that may be used to authorize
    // this key.
    repeated UserAuthType user_auth_type = 13;

    // Specifies the time in seconds for which the key is authorized for use,
    // after authentication.
    .google.protobuf.UInt32Value auth_timeout = 14;

    // This field is applicable only for Android Wear devices with on-body
    // sensors. At this point, it's not expected that any TEE will be able to
    // provide secure access to an on-body sensor, or that on-body sensors are
    // very secure, so this is expected to be a purely software-enforced
    // feature.
    bool allow_while_on_body = 15;

    // Specifies that this key is usable only if the user has provided proof of
    // physical presence.
    // Present only in ATTESTATION_V_THREE and later.
    bool trusted_user_presence_required = 16;

    // Specifies that the key is usable only if the user provides confirmation
    // of the data to be signed using an approval token.
    // Present only in ATTESTATION_V_THREE and later.
    bool trusted_confirmation_required = 17;

    // Present only in ATTESTATION_V_THREE and later.
    bool unlocked_device_required = 18;

    // Indicates whether all apps on a device can access the key pair.
    bool all_applications = 19;
    // Specifies the date and time the key was created.
    .google.protobuf.Timestamp creation_datetime = 21;

    enum KeyOrigin {
      KEY_ORIGIN_UNSPECIFIED = 0;
      // GENERATED indicates that Keymaster/KeyMint generated the key. If in the
      // hardware-enforced list, the key was generated in secure hardware and is
      // permanently hardware bound. If in the software-enforced list, the key
      // was generated in SoftKeymaster and is not hardware bound.
      GENERATED = 1;
      // DERIVED indicates that the key was derived inside Keymaster/KeyMint.
      // Likely exists off-device.
      DERIVED = 2;
      IMPORTED = 3;
      SECURELY_IMPORTED = 4;
    }

    // Specifies where the key was created, if known. This field is set by the
    // secure environment, not the caller.
    KeyOrigin origin = 22;

    // Indicates that the key is rollback-resistant, meaning that when deleted
    // by deleteKey or deleteAllKeys, the key is guaranteed to be permanently
    // deleted and unusable. It's possible that keys without this field could be
    // deleted and then restored from backup.
    // Present only ATTESTATION_V_TWO and earlier. Corresponds to rollback_resistance
    // in ATTESTATION_V_THREE and later.
    bool rollback_resistant = 23;

    // This collection of values defines key information about the device's
    // status.
    message RootOfTrust {
      // A secure hash of the key that verifies the system image. It is
      // recommended that you use the SHA-256 algorithm for this hash.
      bytes verified_boot_key = 1;

      // True if the device's bootloader is locked, which enables Verified Boot
      // checking and prevents an unsigned device image from being flashed onto
      // the device.
      bool device_locked = 2;

      // The boot state of the device, according to the Verified Boot feature.
      // Note: The numeric values do not match the ASN.1 representation.
      enum VerifiedBootState {
        VERIFIED_BOOT_STATE_UNSPECIFIED = 0;
        VERIFIED = 1;
        SELF_SIGNED = 2;
        UNVERIFIED = 3;
        FAILED = 4;
      }

      VerifiedBootState verified_boot_state = 3;

      // A digest of all data protected by Verified Boot. For devices that use
      // the Android Verified Boot implementation of Verified Boot, this value
      // contains the digest of the VBMeta struct, or the Verified Boot metadata
      // structure.
      // Present only in key attestation version 3.
      bytes verified_boot_hash = 4;
    }

    // Specifies the root of trust, the key used by verified boot to validate
    // the operating system booted (if any).
    RootOfTrust root_of_trust = 24;

    // The version of the Android operating system on the device.
    .google.protobuf.UInt32Value os_version = 25;

    // The month and year associated with the security patch level of the system, expressed in an
    // integer as YYYYMM.
    .google.protobuf.UInt32Value os_patch_level = 26;

    // This data structure reflects the Android platform's belief as to which
    // apps are allowed to use the secret key material under attestation. The ID
    // can comprise multiple packages if and only if multiple packages share the
    // same UID.
    message AttestationApplicationId {
      message AttestationPackageInfo {
        .google.protobuf.StringValue package_name = 1;
        .google.protobuf.UInt64Value version = 2;
      }
      // A set of AttestationPackageInfo objects, each providing a package's
      // name and version number.
      repeated AttestationPackageInfo package_infos = 1;
      // A set of SHA-256 digests of the app's signature blobs.
      repeated bytes signature_digests = 2;
    }

    // Used to identify the set of possible applications of which one has
    // initiated a key attestation.
    // Present only in ATTESTATION_V_TWO and later.
    AttestationApplicationId attestation_application_id = 27;

    // Provides the device's brand name, as returned by Build.BRAND in Android.
    // This field is set only when requesting attestation of the device's
    // identifiers.
    // Present only in ATTESTATION_V_TWO and later.
    .google.protobuf.StringValue attestation_id_brand = 28;

    // Provides the device's device name, as returned by Build.DEVICE in
    // Android. This field is set only when requesting attestation of the
    // device's identifiers.
    // Present only in ATTESTATION_V_TWO and later.
    .google.protobuf.StringValue attestation_id_device = 29;

    // Provides the device's product name, as returned by Build.PRODUCT in
    // Android. This field is set only when requesting attestation of the
    // device's identifiers.
    // Present only in ATTESTATION_V_TWO and later.
    .google.protobuf.StringValue attestation_id_product = 30;

    // Provides the device's serial number. This field is set only when
    // requesting attestation of the device's identifiers.
    // Present only in ATTESTATION_V_TWO and later.
    .google.protobuf.StringValue attestation_id_serial = 31;

    // Provides the IMEIs for all radios on the device. This field is set only
    // when requesting attestation of the device's identifiers.
    // Present only in ATTESTATION_V_TWO and later.
    .google.protobuf.StringValue attestation_id_imei = 32;

    // Provides the MEIDs for all radios on the device. This field will only be
    // set when requesting attestation of the device's identifiers.
    // Present only in ATTESTATION_V_TWO and later.
    .google.protobuf.StringValue attestation_id_meid = 33;

    // Provides the device's manufacturer name, as returned by
    // Build.MANUFACTURER in Android. This field is set only when requesting
    // attestation of the device's identifiers.
    // Present only in ATTESTATION_V_TWO and later.
    .google.protobuf.StringValue attestation_id_manufacturer = 34;

    // Provides the device's model name, as returned by Build.MODEL in Android.
    // This field is set only when requesting attestation of the device's
    // identifiers.
    // Present only in ATTESTATION_V_TWO and later.
    .google.protobuf.StringValue attestation_id_model = 35;

    // This field specifies the vendor image security patch level of the device as an integer of the
    // form YYYYMMDD. Present only in ATTESTATION_V_THREE and later.
    .google.protobuf.UInt32Value vendor_patch_level = 36;

    // specifies the boot image (kernel) security patch level of the device as an integer of the
    // form YYYYMMDD. Present only in ATTESTATION_V_THREE and later.
    .google.protobuf.UInt32Value boot_patch_level = 37;
  }

  // The Keymaster/KeyMint authorization list that is enforced by the Android
  // system, not by the device's secure hardware.
  AuthorizationList software_enforced = 7;

  // The Keymaster/KeyMint authorization list that is enforced by the device's
  // secure hardware.
  AuthorizationList hardware_enforced = 8;
}
